import { existsSync, readFileSync, renameSync, writeFileSync } from 'fs';
import { basename, join } from 'path';
import { js2xml, xml2js } from 'xml-js';

import * as msg from './qorus_message';
import { getQorusJavaApiTargetPath } from './qorus_java_utils';

const java_classpath_filename = '.classpath';
const java_project_filename = '.project';

/** Map of Qorus jars */
const qorus_jars = {
    'qore-jni.jar': {
        javadoc: null,
        jar_path: null // will be filled later
    },
    'qorus-client.jar': {
        javadoc: 'qorus-client',
        jar_path: null // will be filled later
    },
    'qorus-common.jar': {
        javadoc: 'qorus-common',
        jar_path: null // will be filled later
    },
    'qorus-job.jar': {
        javadoc: 'qorus-job',
        jar_path: null // will be filled later
    },
    'qorus-mapper.jar': {
        javadoc: 'qorus-mapper',
        jar_path: null // will be filled later
    },
    'qorus-service.jar': {
        javadoc: 'qorus-service',
        jar_path: null // will be filled later
    },
    'qorus-test.jar': {
        javadoc: 'qorus-test',
        jar_path: null // will be filled later
    },
    'qorus-workflow.jar': {
        javadoc: 'qorus-workflow',
        jar_path: null // will be filled later
    }
};

/** Path for default container classpath entry. */
const container_entry_path = 'org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.8';

/** Default container classpath entry. */
const container_classpath_entry = {
    '_attributes': {
        'kind': 'con',
        'path': container_entry_path
    }
};

/** Default Java .classpath file contents */
const default_java_classpath = {
    '_declaration': {
        '_attributes': {
            'version': '1.0',
            'encoding': 'utf-8'
        }
    },
    'classpath': {
        'classpathentry': [] // will be filled later
    }
};

/** Default Java .project file contents */
const default_java_project = {
    '_declaration': {
        '_attributes': {
            'version': '1.0',
            'encoding': 'utf-8'
        }
    },
    'projectDescription': {
        'name': {
            '_text': 'name' // will be filled later
        },
        'comment': {
            '_text': 'Generated by qorus-vscode.'
        },
        'projects': {},
        'natures': {
            'nature': {
                '_text': 'org.eclipse.jdt.core.javanature'
            }
        }
    }
};

export class QorusProjectJavaConfig {
    private project_folder: string;
    private classpath;
    private project;

    constructor(projectFolder: string) {
        this.project_folder = projectFolder;
        this.updateQorusJarsInfo();
    }

    /** Update info in the Qorus jars map (like jar paths etc.). */
    private updateQorusJarsInfo() {
        const api_target_path = getQorusJavaApiTargetPath();
        for (const jar in qorus_jars) {
            if (qorus_jars.hasOwnProperty(jar)) {
                qorus_jars[jar].jar_path = join(api_target_path, jar);
            }
        }
    }

    /** Return path to classpath file in the project folder. */
    get java_classpath_file(): string {
        return join(this.project_folder, java_classpath_filename);
    }

    /** Return path to project file in the project folder. */
    get java_project_file(): string {
        return join(this.project_folder, java_project_filename);
    }

    classpathFileExists(): boolean {
        return existsSync(this.java_classpath_file);
    }

    projectFileExists(): boolean {
        return existsSync(this.java_project_file);
    }

    /** Find out which jars are present in the classpath. */
    private findPresentJars(classpathentry) {
        const jar_present_map = {};

        // create map and fill it with defaults
        for (const jar in qorus_jars) {
            if (qorus_jars.hasOwnProperty(jar)) {
                jar_present_map[qorus_jars[jar].jar_path] = {
                    jar: jar,
                    present: false
                };
            }
        }

        // check that all qorus jars are present
        for (const entry of classpathentry) {
            if (entry._attributes && entry._attributes.path
                && jar_present_map.hasOwnProperty(entry._attributes.path))
            {
                jar_present_map[entry._attributes.path].present = true;
            }
        }

        return jar_present_map;
    }

    /** Return whether all jars are present in the classpathentry. */
    private allJarsPresent(jar_present_map): boolean {
        for (const jar in jar_present_map) {
            if (jar_present_map.hasOwnProperty(jar)) {
                if (!jar_present_map[jar].present) {
                    return false;
                }
            }
        }
        return true;
    }

    /** Return whether container entry is present in the classpathentry. */
    private containerEntryPresent(classpathentry): boolean {
        for (const entry of classpathentry) {
            if (entry._attributes &&
                entry._attributes.kind === 'con' &&
                entry._attributes.path === container_entry_path)
            {
                return true;
            }
        }
        return false;
    }

    private getJavadocPath(javadoc: string): string {
        const api_target_path = getQorusJavaApiTargetPath();
        return join(api_target_path, 'javadoc', javadoc);
    }

    private getJavadocLocationString(javadoc: string): string {
        return 'file:' + this.getJavadocPath(javadoc);
    }

    private getClasspathEntryForJar(jar) {
        const _attributes = {
            'kind': 'lib',
            'path': qorus_jars[jar].jar_path
        };
        let entry = {};
        if (qorus_jars[jar].javadoc) {
            entry = {
                '_attributes': _attributes,
                'attributes': {
                    'attribute': {
                        '_attributes': {
                            'name': 'javadoc_location',
                            value: this.getJavadocLocationString(qorus_jars[jar].javadoc)
                        },
                    }
                }
            };
        } else {
            entry = {
                '_attributes': _attributes
            };
        }
        return entry;
    }

    /** Fill missing jar entries into the classpathentry. */
    private fillMissingClasspathEntries(classpathentry) {
        const jar_present_map = this.findPresentJars(classpathentry);
        for (const jar in jar_present_map) {
            if (jar_present_map.hasOwnProperty(jar)) {
                if (!jar_present_map[jar].present) {
                    classpathentry.push(this.getClasspathEntryForJar(jar_present_map[jar].jar));
                }
            }
        }
    }

    /** Add container entry to the classpathentry. */
    private addContainerClasspathEntry(classpathentry) {
        classpathentry.push(container_classpath_entry);
    }

    /** Validate whether the loaded classpath has basic necessities. */
    private validateClasspath(): boolean {
        if (this.classpath === null || typeof this.classpath !== 'object') {
            return false;
        }
        if (!this.classpath.classpath) {
            return false;
        }
        return true;
    }

    /** Validate whether the loaded project has basic necessities. */
    private validateProject(): boolean {
        if (this.project === null || typeof this.project !== 'object') {
            return false;
        }
        if (!this.project.projectDescription) {
            return false;
        }
        return true;
    }

    /** Return whether the loaded classpath has Qorus API configured. */
    private classpathContainsQorusApi(): boolean {
        if (!this.classpath.classpath.classpathentry) {
            return false;
        }

        // check that all jars are present in the classpath
        if (Array.isArray(this.classpath.classpath.classpathentry)) {
            const jar_present_map = this.findPresentJars(this.classpath.classpath.classpathentry);
            return this.allJarsPresent(jar_present_map) &&
                this.containerEntryPresent(this.classpath.classpath.classpathentry);
        }
        return false;
    }

    /** Load classpath from the classpath XML file into a JS object. */
    loadClasspath(): boolean {
        const classpathFile = this.java_classpath_file;
        if (!existsSync(classpathFile)) {
            return false;
        }
        try {
            const classpath_xml = readFileSync(classpathFile, 'utf8');
            this.classpath = xml2js(classpath_xml, {compact: true});
            if (!this.validateClasspath()) {
                this.classpath = undefined;
                return false;
            }
            return this.classpathContainsQorusApi();
        } catch (error) {
            msg.log('Error loading Java classpath: ' + error);
            return false;
        }
    }

    /** Load project from the project XML file into a JS object. */
    loadProject(): boolean {
        const projectFile = this.java_project_file;
        if (!existsSync(projectFile)) {
            return false;
        }
        try {
            const project_xml = readFileSync(projectFile, 'utf8');
            this.project = xml2js(project_xml, {compact: true});
            if (!this.validateProject()) {
                this.project = undefined;
                return false;
            }
            return true;
        } catch (error) {
            msg.log('Error loading Java project: ' + error);
            return false;
        }
    }

    /** Fix the loaded classpath if the Qorus API configuration is missing. */
    fixClasspath() {
        // fix missing/empty classpath or classpathentry keys
        if (!this.classpath) {
            this.classpath = default_java_classpath;
        }
        else if (!this.classpath.classpath.classpathentry) {
            this.classpath.classpath.classpathentry =
                default_java_classpath.classpath.classpathentry;
        }

        // if classpathentry is not array, transform it into one
        if (!Array.isArray(this.classpath.classpath.classpathentry)) {
            this.classpath.classpath.classpathentry = [
                this.classpath.classpath.classpathentry,
            ];
        }

        // add container classpath entry if missing
        if (!this.containerEntryPresent(this.classpath.classpath.classpathentry)) {
            this.addContainerClasspathEntry(this.classpath.classpath.classpathentry);
        }

        // fill the missing jar entries
        this.fillMissingClasspathEntries(this.classpath.classpath.classpathentry);
    }

    /** Fix the loaded project if the Qorus API configuration is missing. */
    fixProject() {
        if (!this.project) {
            this.project = default_java_project;
            this.project.projectDescription.name._text =
                basename(this.project_folder);
            return;
        }
    }

    /** Generate XML from the fixed classpath data. */
    private generateClasspathXml(): string {
        return js2xml(this.classpath, {compact: true, spaces: 4});
    }

    /** Generate XML from the fixed project data. */
    private generateProjectXml(): string {
        return js2xml(this.project, {compact: true, spaces: 4});
    }

    /** Write a new classpath file and overwrite the old one with it. */
    writeClasspathFile(): boolean {
        const finalFile = this.java_classpath_file;
        const newFile = finalFile + '.new';
        try {
            writeFileSync(newFile, this.generateClasspathXml());
        } catch (err) {
            msg.log('Failed writing new Java classpath file: ' + err);
            return false;
        }
        try {
            renameSync(newFile, finalFile);
        } catch (err) {
            msg.log('Failed rewriting old Java classpath file: ' + err);
            return false;
        }
        return true;
    }

    /** Write a new project file and overwrite the old one with it. */
    writeProjectFile(): boolean {
        const finalFile = this.java_project_file;
        const newFile = finalFile + '.new';
        try {
            writeFileSync(newFile, this.generateProjectXml());
        } catch (err) {
            msg.log('Failed writing new Java project file: ' + err);
            return false;
        }
        try {
            renameSync(newFile, finalFile);
        } catch (err) {
            msg.log('Failed rewriting old Java project file: ' + err);
            return false;
        }
        return true;
    }
}
